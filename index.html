<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Advanced Jump & Run - Blue Square</title>
<style>
  :root{--bg:#111;--panel:#0f1720;--text:#e6eef8}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%,#021018 100%);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
  #gameWrap{display:flex;gap:16px;padding:18px}
  canvas{background:linear-gradient(#7ec0ff00,#00000055);box-shadow:0 10px 30px #0006;border-radius:6px}
  .sidebar{width:300px;background:rgba(255,255,255,0.03);padding:12px;border-radius:8px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
  h1{font-size:18px;margin:0 0 8px}
  .legend{display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:13px}
  .chip{display:flex;align-items:center;gap:8px;padding:6px;border-radius:6px}
  .color{width:26px;height:18px;border-radius:3px;flex:0 0 26px}
  .controls{margin-top:12px;font-size:13px}
  button{background:#0ea5a4;border:0;padding:8px 10px;border-radius:6px;color:#032;cursor:pointer}
  footer{margin-top:12px;font-size:12px;color:#9fb}
</style>
</head>
<body>
<div id="gameWrap">
  <canvas id="c"></canvas>
  <div class="sidebar">
    <h1>Advanced Jump & Run - Blue Square</h1>
    <div>Controls:</div>
    <div class="controls">
      W or Space - Jump<br>
      A - Move left<br>
      D - Move right<br>
      S - Stomp (fast fall while airborne)<br>
    </div>

    <h3 style="margin-top:12px">Legend</h3>
    <div class="legend">
      <div class="chip"><div class="color" style="background:#2b8cff"></div>Player (blue square)</div>
      <div class="chip"><div class="color" style="background:#9aa0a6"></div>Platform (solid)</div>
      <div class="chip"><div class="color" style="background:#ff4d4d"></div>Enemy (danger)</div>
      <div class="chip"><div class="color" style="background:#22c55e"></div>Trampoline (bouncy)</div>
      <div class="chip"><div class="color" style="background:#ffdd57"></div>Coin (collect)</div>
      <div class="chip"><div class="color" style="background:#ff7a1a"></div>Moving platform</div>
      <div class="chip"><div class="color" style="background:#000"></div>Spikes (instant death)</div>
      <div class="chip"><div class="color" style="background:#7c3aed"></div>Goal (finish level)</div>
    </div>

    <div style="margin-top:12px">
      <button id="restartBtn">Restart Level</button>
      <button id="muteBtn">Mute</button>
    </div>

    <footer>
      12 levels included • Color-coded objects • Uses W/A/S/D + Space • Open this file in your browser to play
    </footer>
  </div>
</div>
<script>
/*
  Advanced Jump & Run (single-file) - UPDATED
  Fixes: enemy initialization, spike collisions, coin placement snap-to-surface.
  Added: jump and land FX, improved enemy behaviour, safer coin placements.
*/

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
let tileSize = 48;
let cols = 28; // horizontal tiles visible
let rows = 14;
canvas.width = cols * tileSize;
canvas.height = rows * tileSize;

let keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if ([' ','w'].includes(e.key.toLowerCase())) e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

document.getElementById('restartBtn').addEventListener('click', ()=> restartLevel());
let muted=false; document.getElementById('muteBtn').addEventListener('click', ()=>{ muted=!muted; document.getElementById('muteBtn').textContent = muted? 'Unmute':'Mute'; });

// Colors
const COLORS = {
  bg: '#071025',
  platform: '#9aa0a6',
  player: '#2b8cff',
  enemy: '#ff4d4d',
  trampoline: '#22c55e',
  coin: '#ffdd57',
  movingPlatform: '#ff7a1a',
  spikes: '#000000',
  goal: '#7c3aed'
};

// Game state
let levelIndex = 0;
let score = 0;
let lives = 3;
let camera = {x:0,y:0};

// Entities arrays
let solids = []; // rectangles: {x,y,w,h,type}
let platforms = []; // moving platforms
let enemies = [];
let coins = [];
let trampolines = [];
let spikes = [];
let goal = null;

// Player
let player = {
  x: 100,
  y: 0,
  w: tileSize*0.6,
  h: tileSize*0.8,
  vx: 0,
  vy: 0,
  speed: 360, // px/sec
  jumpPower: 760,
  onGround: false,
};
let prevOnGround = false;

const GRAV = 2200; // px/sec^2
const STOMP_SPEED = 1400;
const BOUNCE_FROM_ENEMY = 520;
const TRAMPOLINE_BOOST = 1100;

// Timing
let last = performance.now();

// -- LEVEL BUILDER --
function makeEmptyLevel(w,h){
  return {w,w,h,playerStart:{x:80,y:0},solids:[],platforms:[],enemies:[],coins:[],trampolines:[],spikes:[],goal:null};
}

function rect(x,y,w,h){ return {x,y,w,h}; }

function buildLevels(){
  const levels = [];
  // Level 1 - tutorial small
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart = {x:tileSize*2,y:tileSize*8};
    // ground
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    // some platforms
    L.solids.push(rect(tileSize*6,tileSize*9,tileSize*6,tileSize*1));
    L.coins.push({x:tileSize*7.5,y:tileSize*2});
    L.trampolines.push({x:tileSize*14,y:tileSize*11,w:tileSize,h:tileSize});
    L.solids.push(rect(tileSize*13,tileSize*10,tileSize*3,tileSize*1));
    L.enemies.push({x:tileSize*18,y:tileSize*11,w:tileSize*0.8,h:tileSize*0.8,range:tileSize*4});
    L.goal = {x:tileSize*(cols-2),y:tileSize*10,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 2 - spikes (adjusted spike y so it can hit player when on ground)
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart = {x:tileSize*2,y:tileSize*9};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    L.solids.push(rect(tileSize*6,tileSize*10,tileSize*3,tileSize*1));
    L.spikes.push(rect(tileSize*10,tileSize*12 - tileSize*0.5,tileSize*2,tileSize));
    L.coins.push({x:tileSize*8.5,y:tileSize*2});
    L.enemies.push({x:tileSize*16,y:tileSize*11,w:tileSize*0.8,h:tileSize*0.8,range:tileSize*6});
    L.goal = {x:tileSize*(cols-2),y:tileSize*10,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 3 - moving platform
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*1.5,y:tileSize*9};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    L.platforms.push({x:tileSize*8,y:tileSize*9,w:tileSize*4,h:tileSize,dx:120,minX:tileSize*6,maxX:tileSize*18});
    L.trampolines.push({x:tileSize*20,y:tileSize*11,w:tileSize,h:tileSize});
    L.enemies.push({x:tileSize*24,y:tileSize*11,w:tileSize*0.8,h:tileSize*0.8,range:tileSize*5});
    L.coins.push({x:tileSize*10.5,y:tileSize*2});
    L.goal = {x:tileSize*(cols-2),y:tileSize*10,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 4 - long jump sequence (coins placed on reachable platforms)
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*9};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    for(let i=0;i<8;i++){ L.solids.push(rect(tileSize*(6+i*3),tileSize*(10 - (i%2)),tileSize*2,tileSize)); }
    L.enemies.push({x:tileSize*10,y:tileSize*11,w:tileSize*0.8,h:tileSize*0.8,range:tileSize*2});
    // place coin on a mid platform
    L.coins.push({x:tileSize*12.5,y:tileSize*2});
    L.trampolines.push({x:tileSize*28,y:tileSize*11,w:tileSize,h:tileSize});
    L.goal = {x:tileSize*(cols-3),y:tileSize*8,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 5 - vertical shafts + stomp
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*3};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    for(let i=0;i<6;i++){ L.solids.push(rect(tileSize*(6+i*3),tileSize*(11 - (i%3)*3),tileSize,tileSize*( (i%3)+1 ))); }
    L.spikes.push(rect(tileSize*15,tileSize*12 - tileSize*0.5,tileSize*2,tileSize));
    L.enemies.push({x:tileSize*11,y:tileSize*7,w:tileSize*0.8,h:tileSize*0.8,range:tileSize*6});
    L.coins.push({x:tileSize*20,y:tileSize*2});
    L.goal = {x:tileSize*(cols-2),y:tileSize*10,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 6 - moving enemies and narrow platforms
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*8};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    for(let i=0;i<10;i++){ L.solids.push(rect(tileSize*(4+i*2),tileSize*(10 - (i%2)),tileSize,tileSize)); }
    L.enemies.push({x:tileSize*14,y:tileSize*9,w:tileSize*0.8,h:tileSize*0.8,range:tileSize*10});
    L.enemies.push({x:tileSize*22,y:tileSize*9,w:tileSize*0.8,h:tileSize*0.8,range:tileSize*6});
    L.coins.push({x:tileSize*12,y:tileSize*2});
    L.goal = {x:tileSize*(cols-2),y:tileSize*9,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 7 - mix: trampolines & spikes
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*9};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    L.trampolines.push({x:tileSize*8,y:tileSize*11,w:tileSize,h:tileSize});
    L.trampolines.push({x:tileSize*14,y:tileSize*8,w:tileSize,h:tileSize});
    L.spikes.push(rect(tileSize*18,tileSize*12 - tileSize*0.5,tileSize*3,tileSize));
    L.enemies.push({x:tileSize*22,y:tileSize*11,w:tileSize*0.8,h:tileSize*0.8,range:tileSize*4});
    L.goal = {x:tileSize*(cols-3),y:tileSize*9,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 8 - puzzle platforms
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*10};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    L.platforms.push({x:tileSize*6,y:tileSize*10,w:tileSize*3,h:tileSize,dx:90,minX:tileSize*6,maxX:tileSize*20});
    L.platforms.push({x:tileSize*18,y:tileSize*6,w:tileSize*4,h:tileSize,dx:60,minX:tileSize*10,maxX:tileSize*26});
    L.coins.push({x:tileSize*19,y:tileSize*2});
    L.goal = {x:tileSize*(cols-2),y:tileSize*9,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 9 - enemy gauntlet
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*9};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    for(let i=0;i<6;i++){ L.enemies.push({x:tileSize*(10+i*3),y:tileSize*11,w:tileSize*0.9,h:tileSize*0.9,range:tileSize*(2 + (i%3)*2)}); }
    L.coins.push({x:tileSize*22,y:tileSize*2});
    L.goal = {x:tileSize*(cols-3),y:tileSize*9,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 10 - long level with many coins
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*10};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    for(let i=0;i<10;i++){ L.solids.push(rect(tileSize*(6+i*2),tileSize*(10 - (i%3)),tileSize,tileSize)); L.coins.push({x:tileSize*(7+i*2),y:tileSize*2}); }
    L.goal = {x:tileSize*(cols-2),y:tileSize*9,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 11 - boss-like enemy (fast patrol)
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*9};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    L.enemies.push({x:tileSize*14,y:tileSize*11,w:tileSize*1.2,h:tileSize*1.2,range:tileSize*14, speed: 120});
    L.trampolines.push({x:tileSize*7,y:tileSize*11,w:tileSize,h:tileSize});
    L.goal = {x:tileSize*(cols-2),y:tileSize*9,w:tileSize,h:tileSize};
    levels.push(L);
  }
  // Level 12 - final: combo
  { let L=makeEmptyLevel(cols,rows);
    L.playerStart={x:tileSize*2,y:tileSize*9};
    L.solids.push(rect(0,tileSize*12,cols*tileSize,tileSize*2));
    for(let i=0;i<7;i++){ L.solids.push(rect(tileSize*(6+i*3),tileSize*(10 - ((i+1)%2)),tileSize*2,tileSize)); }
    L.platforms.push({x:tileSize*10,y:tileSize*7,w:tileSize*3,h:tileSize,dx:110,minX:tileSize*8,maxX:tileSize*22});
    L.trampolines.push({x:tileSize*4,y:tileSize*11,w:tileSize,h:tileSize});
    L.enemies.push({x:tileSize*18,y:tileSize*11,w:tileSize*0.9,h:tileSize*0.9,range:tileSize*6});
    L.spikes.push(rect(tileSize*22,tileSize*12 - tileSize*0.5,tileSize*3,tileSize));
    L.coins.push({x:tileSize*12,y:tileSize*2});
    L.goal = {x:tileSize*(cols-2),y:tileSize*8,w:tileSize,h:tileSize};
    levels.push(L);
  }

  return levels;
}

const LEVELS = buildLevels();
const LEVEL_COUNT = LEVELS.length;

function loadLevel(idx){
  const L = LEVELS[idx];
  solids = L.solids.map(s=>Object.assign({},s));
  platforms = L.platforms.map(p=>Object.assign({},p));
  enemies = L.enemies.map(e=>{ let n = Object.assign({vx: (e.speed||60)}, e); n.alive = true; n.baseX = (typeof n.range === 'number') ? (n.x - n.range/2) : n.x; n.direction = 1; return n; });
  coins = L.coins.map(c=>Object.assign({},c));
  trampolines = L.trampolines.map(t=>Object.assign({},t));
  spikes = L.spikes.map(s=>Object.assign({},s));
  goal = L.goal? Object.assign({},L.goal): null;
  player.x = L.playerStart.x; player.y = L.playerStart.y; player.vx=0; player.vy=0; player.onGround=false;
  prevOnGround = false;
  camera.x = 0; camera.y = 0;

  // snap coins onto nearest surface (platform/solid) so they're reachable
  const surfaces = solids.concat(platforms);
  for(let c of coins){
    let placed = false;
    for(let s of surfaces){ if(c.x >= s.x && c.x <= s.x + s.w){ c.y = s.y - 12; placed = true; break; } }
    if(!placed && solids.length>0) c.y = solids[0].y - 12; // default to ground
  }
}

loadLevel(levelIndex);

function restartLevel(){ loadLevel(levelIndex); }

function nextLevel(){ levelIndex++; if(levelIndex>=LEVEL_COUNT){ alert('Congratulations! You finished all levels. Restarting from level 1.'); levelIndex=0; } loadLevel(levelIndex); }

// Simple AABB collision
function aabb(a,b){ return !(a.x + a.w <= b.x || a.x >= b.x + b.w || a.y + a.h <= b.y || a.y >= b.y + b.h); }

function update(dt){
  // input
  let left = keys['a'];
  let right = keys['d'];
  let jumpPressed = (keys['w'] || keys[' ']);
  let stompPressed = keys['s'];

  prevOnGround = player.onGround;

  // horizontal movement
  if(left && !right) player.vx = -player.speed;
  else if(right && !left) player.vx = player.speed;
  else player.vx = 0;

  // jumping
  if(jumpPressed && player.onGround){ player.vy = -player.jumpPower; player.onGround=false; if(!muted) playSound('jump'); }

  // stomp
  if(stompPressed && !player.onGround){ player.vy = Math.max(player.vy, STOMP_SPEED); }

  // apply gravity
  player.vy += GRAV * dt;

  // integrate X
  let nextX = player.x + player.vx * dt;
  let bboxX = {x: nextX, y: player.y, w: player.w, h: player.h};
  let collidedX = false;
  for(let s of solids){ if(aabb(bboxX,s)){ collidedX = true; break; } }
  for(let p of platforms){ if(aabb(bboxX,p)){ collidedX = true; break; } }
  if(!collidedX) player.x = nextX; else player.vx = 0;

  // integrate Y
  let nextY = player.y + player.vy * dt;
  let bboxY = {x: player.x, y: nextY, w: player.w, h: player.h};
  player.onGround = false;
  // check platforms/solids collisions
  let resolved = false;
  // check solids
  for(let s of solids){ if(aabb(bboxY,s)){
      // if falling onto platform
      if(player.vy > 0 && player.y + player.h <= s.y + 6){ // landed
        player.y = s.y - player.h; player.vy = 0; player.onGround = true; resolved = true; break;
      } else if(player.vy < 0 && player.y >= s.y + s.h - 6){ // hit head
        player.y = s.y + s.h; player.vy = 0; resolved = true; break;
      } else { // side collision
        if(player.x + player.w/2 < s.x + s.w/2) player.x = s.x - player.w; else player.x = s.x + s.w; player.vx = 0; resolved = true; break;
      }
    }
  }
  if(!resolved){
    // moving platforms
    for(let p of platforms){ if(aabb(bboxY,p)){
        if(player.vy > 0 && player.y + player.h <= p.y + 6){ player.y = p.y - player.h; player.vy = 0; player.onGround = true; // ride platform
          player.x += (p.dx) * dt; resolved = true; break; }
        else if(player.vy < 0 && player.y >= p.y + p.h - 6){ player.y = p.y + p.h; player.vy = 0; resolved = true; break; }
        else { if(player.x + player.w/2 < p.x + p.w/2) player.x = p.x - player.w; else player.x = p.x + p.w; player.vx = 0; resolved = true; break; }
      }}
  }
  if(!resolved) player.y = nextY;

  // landing sound
  if(!prevOnGround && player.onGround){ if(!muted) playSound('land'); }

  // trampolines
  for(let t of trampolines){ if(aabb(player,{x:t.x,y:t.y,w:t.w,h:t.h})){ if(player.vy>0){ player.vy = -TRAMPOLINE_BOOST; player.onGround=false; if(!muted) playSound('boing'); } } }

  // spikes
  for(let s of spikes){ if(aabb(player,s)){ playerDie(); return; } }

  // coins
  for(let i=coins.length-1;i>=0;i--){ let c=coins[i]; if(aabb(player,{x:c.x-10,y:c.y-10,w:20,h:20})){ score += 10; coins.splice(i,1); if(!muted) playSound('coin'); } }

  // goal
  if(goal && aabb(player,goal)){ if(!muted) playSound('complete'); nextLevel(); return; }

  // enemies
  for(let i=enemies.length-1;i>=0;i--){ let e = enemies[i]; if(e.alive === false) continue;
    // update patrol
    let speed = e.vx || 60;
    if(!e.direction) e.direction = 1;
    e.x += e.direction * speed * dt;
    if(e.range){ if(e.x < e.baseX) e.direction = 1; if(e.x > e.baseX + e.range) e.direction = -1; }
    // collision with player
    if(aabb(player,{x:e.x,y:e.y,w:e.w,h:e.h})){
      // stomp
      if(player.vy > 200){ // falling onto enemy
        e.alive = false; player.vy = -BOUNCE_FROM_ENEMY; score += 30; if(!muted) playSound('stomp');
      } else { playerDie(); return; }
    }
  }

  // moving platforms update
  for(let p of platforms){ p.x += Math.sign(p.dx) * Math.abs(p.dx) * dt; if(p.x < p.minX) p.x = p.minX, p.dx = Math.abs(p.dx); if(p.x > p.maxX) p.x = p.maxX, p.dx = -Math.abs(p.dx); }

  // camera follow
  let targetX = player.x + player.w/2 - canvas.width/2;
  let targetY = player.y + player.h/2 - canvas.height/2;
  camera.x += (targetX - camera.x) * Math.min(1,10*dt);
  camera.y += (targetY - camera.y) * Math.min(1,10*dt);
  // clamp
  camera.x = Math.max(0, Math.min(camera.x, cols*tileSize - canvas.width));
  camera.y = Math.max(0, Math.min(camera.y, rows*tileSize - canvas.height));
}

function playerDie(){ lives--; if(lives<=0){ alert('Game over. Restarting.'); lives = 3; score = 0; levelIndex = 0; } loadLevel(levelIndex); }

function draw(){
  // clear
  ctx.fillStyle = COLORS.bg; ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.save(); ctx.translate(-camera.x, -camera.y);

  // draw solids
  for(let s of solids){ ctx.fillStyle = COLORS.platform; ctx.fillRect(s.x, s.y, s.w, s.h); }
  // draw moving platforms
  for(let p of platforms){ ctx.fillStyle = COLORS.movingPlatform; ctx.fillRect(p.x, p.y, p.w, p.h); }
  // draw trampolines
  for(let t of trampolines){ ctx.fillStyle = COLORS.trampoline; ctx.fillRect(t.x, t.y, t.w, t.h); ctx.fillStyle='rgba(0,0,0,0.12)'; ctx.fillRect(t.x+4, t.y+4, t.w-8, t.h-8); }
  // spikes
  for(let s of spikes){ ctx.fillStyle = COLORS.spikes; ctx.fillRect(s.x, s.y, s.w, s.h); // draw triangles
    let cols = Math.max(1, Math.floor(s.w/12));
    for(let i=0;i<cols;i++){ let px = s.x + i*(s.w/cols); ctx.beginPath(); ctx.moveTo(px, s.y + s.h); ctx.lineTo(px + (s.w/cols)/2, s.y); ctx.lineTo(px + (s.w/cols), s.y + s.h); ctx.fill(); }
  }
  // coins
  for(let c of coins){ ctx.fillStyle = COLORS.coin; ctx.beginPath(); ctx.arc(c.x, c.y, 8,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(0,0,0,0.2)'; ctx.stroke(); }
  // goal
  if(goal){ ctx.fillStyle = COLORS.goal; ctx.fillRect(goal.x, goal.y, goal.w, goal.h); ctx.fillStyle='white'; ctx.fillRect(goal.x+goal.w*0.25, goal.y+goal.h*0.25, goal.w*0.5, goal.h*0.5); }

  // enemies
  for(let e of enemies){ if(e.alive === false) continue; ctx.fillStyle = COLORS.enemy; ctx.fillRect(e.x, e.y, e.w, e.h); ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fillRect(e.x, e.y, e.w, e.h*0.2); }

  // player
  ctx.fillStyle = COLORS.player; ctx.fillRect(player.x, player.y, player.w, player.h);

  ctx.restore();

  // HUD
  ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(8,8,260,84);
  ctx.fillStyle = '#fff'; ctx.font = '14px system-ui'; ctx.fillText('Level: ' + (levelIndex+1) + ' / ' + LEVEL_COUNT, 16, 28);
  ctx.fillText('Score: ' + score, 16, 48);
  ctx.fillText('Lives: ' + lives, 16, 68);
  ctx.fillText('Coins: ' + coins.length + ' remaining', 16, 88);
}

// Simple sounds using WebAudio - tiny beeps
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(type){ if(muted) return; try{
  let o = audioCtx.createOscillator(); let g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
  switch(type){
    case 'coin': o.frequency.value = 880; g.gain.value=0.06; o.start(); o.stop(audioCtx.currentTime+0.08); break;
    case 'boing': o.frequency.value = 220; g.gain.value=0.12; o.start(); o.stop(audioCtx.currentTime+0.25); break;
    case 'stomp': o.frequency.value = 120; g.gain.value=0.12; o.start(); o.stop(audioCtx.currentTime+0.12); break;
    case 'complete': o.frequency.value = 440; g.gain.value=0.12; o.start(); o.stop(audioCtx.currentTime+0.4); break;
    case 'jump': o.frequency.value = 520; g.gain.value=0.06; o.start(); o.stop(audioCtx.currentTime+0.08); break;
    case 'land': o.frequency.value = 180; g.gain.value=0.09; o.start(); o.stop(audioCtx.currentTime+0.12); break;
  }
 }catch(e){ /* audio may be locked by browser until user interacts */ }
}

function loop(t){ let now = t; let dt = Math.min(0.033, (now - last)/1000); last = now; update(dt); draw(); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// Resize canvas responsively
window.addEventListener('resize', ()=>{
  const scale = Math.min(1, (window.innerHeight - 40) / (rows*tileSize));
  canvas.style.width = Math.round(cols*tileSize*scale)+'px';
  canvas.style.height = Math.round(rows*tileSize*scale)+'px';
}); window.dispatchEvent(new Event('resize'));

</script>
</body>
</html>
